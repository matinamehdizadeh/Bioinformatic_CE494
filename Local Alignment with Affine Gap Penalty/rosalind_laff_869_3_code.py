from Bio import SeqIO

score_matrix = [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2],
                [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2],
                [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3],
                [-1, -4, 2, 5, -3, -2, 0, -3, 1, -3, -2, 0, -1, 2, 0, 0, -1, -2, -3, -2],
                [-2, -2, -3, -3, 6, -3, -1, 0, -3, 0, 0, -3, -4, -3, -3, -2, -2, -1, 1, 3],
                [0, -3, -1, -2, -3, 6, -2, -4, -2, -4, -3, 0, -2, -2, -2, 0, -2, -3, -2, -3],
                [-2, -3, -1, 0, -1, -2, 8, -3, -1, -3, -2, 1, -2, 0, 0, -1, -2, -3, -2, 2],
                [-1, -1, -3, -3, 0, -4, -3, 4, -3, 2, 1, -3, -3, -3, -3, -2, -1, 3, -3, -1],
                [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2],
                [-1, -1, -4, -3, 0, -4, -3, 2, -2, 4, 2, -3, -3, -2, -2, -2, -1, 1, -2, -1],
                [-1, -1, -3, -2, 0, -3, -2, 1, -1, 2, 5, -2, -2, 0, -1, -1, -1, 1, -1, -1],
                [-2, -3, 1, 0, -3, 0, 1, -3, 0, -3, -2, 6, -2, 0, 0, 1, 0, -3, -4, -2],
                [-1, -3, -1, -1, -4, -2, -2, -3, -1, -3, -2, -2, 7, -1, -2, -1, -1, -2, -4, -3],
                [-1, -3, 0, 2, -3, -2, 0, -3, 1, -2, 0, 0, -1, 5, 1, 0, -1, -2, -2, -1],
                [-1, -3, -2, 0, -3, -2, 0, -3, 2, -2, -1, 0, -2, 1, 5, -1, -1, -3, -3, -2],
                [1, -1, 0, 0, -2, 0, -1, -2, 0, -2, -1, 1, -1, 0, -1, 4, 1, -2, -3, -2],
                [0, -1, -1, -1, -2, -2, -2, -1, -1, -1, -1, 0, -1, -1, -1, 1, 5, 0, -2, -2],
                [0, -1, -3, -2, -1, -3, -3, 3, -2, 1, 1, -3, -2, -2, -3, -2, 0, 4, -3, -1],
                [-3, -2, -4, -3, 1, -2, -2, -3, -3, -2, -1, -4, -4, -2, -3, -3, -2, -3, 11, 2],
                [-2, -2, -3, -2, 3, -3, 2, -1, -2, -1, -1, -2, -3, -1, -2, -2, -2, -1, 2, 7]]
find_middle = [0, -1, 1, 2, 3, 4, 5, 6, 7, -1, 8, 9, 10, 11, -1, 12, 13, 14, 15, 16, -1, 17, 18, -1, 19, -1]
inputs = []

with open('rosalind_laff.fasta', 'r') as f:
    for record in SeqIO.parse(f, 'fasta'):
        inputs.append(str(record.seq))
s1 = inputs[0]
t1 = inputs[1]

n1 = len(s1)
n2 = len(t1)

dpM = [[0 for x in range(n2 + 1)] for y in range(n1 + 1)]
dpU = [[0 for x in range(n2 + 1)] for y in range(n1 + 1)]
dpD = [[0 for x in range(n2 + 1)] for y in range(n1 + 1)]

maximum = -1
for i in range(1, n1 + 1):
    for j in range(1, n2 + 1):

        x = dpU[i - 1][j] - 1
        y = dpM[i - 1][j] - 11
        dpU[i][j] = max(x, y)

        x = dpD[i][j - 1] - 1
        y = dpM[i][j - 1] - 11
        dpD[i][j] = max(x, y)

        a = ord(s1[i - 1]) - ord('A')
        b = ord(t1[j - 1]) - ord('A')
        z = dpM[i - 1][j - 1] + score_matrix[find_middle[a]][find_middle[b]]
        dpM[i][j] = max(dpD[i][j], dpU[i][j], z, 0)

        if dpM[i][j] > maximum:
            maximum = dpM[i][j]
            first_index = i
            second_index = j

i = first_index
j = second_index
s = ''
t = ''
while (i > 0) and (j > 0):
    a = ord(s1[i - 1]) - ord('A')
    b = ord(t1[j - 1]) - ord('A')
    if dpM[i][j] == dpM[i - 1][j - 1] + score_matrix[find_middle[a]][find_middle[b]]:
        s = s1[i - 1] + s
        t = t1[j - 1] + t
        i -= 1
        j -= 1
    elif dpM[i][j] == dpU[i][j]:
        s = s1[i - 1] + s
        i -= 1
    elif dpM[i][j] == dpD[i][j]:
        t = t1[j - 1] + t
        j -= 1
    else:
        break

print(maximum)
print(s)
print(t)